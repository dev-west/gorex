# gorex
Regular expression syntax builder to introduce basic concepts. Note: interface still in flux.

## usage
Regular expressions are an efficient means to search and match a pattern against a collection of text.

These expressions can be obtuse enough to discourage their usage. This package provides a simple collection of functions such that an expression can be generated by an easily understood sequence of function calls. The example found in `example_main.go` provides a simple e-mail regular expression.

This package creates a sequence of groups with each add command. These groups are represented in regular expressions in parentheses. In each group, gorex supports either a class of individual characters or a collection of fixed strings. Classes of characters are things like any upper-case letter (Uppers A through Z) or any numeral (Numerics 0 through 9). Fixed strings are things commonly found in a fixed sequence like the top-level domain of an e-mail address ('.com', '.net', etc).

Classes are added to the expression in square brackets expecting the use of a quantifier. Square brackets in these expressions list a collection of matching options **for a single character**. So if you add multiple classes to a particular group, any character that matches any class added will be accepted. These are commonly added using the `OneOrMore` quantifier, meaning as long as there's one character, there can be as many characters in a row, provided they match the classes in that group.

Fixed strings are added to the expression without square brackets, but may also support quantifiers.

## functionality
GolangExpression(string options) (gorex, error) produces a gorex object and its related functions the following functions are all accessible via any gorex object created.
Supported options:
      "Unsafe": normal behavior prevents class strings outside the defined constants. This option permits any string to be passed through classes.

gorex.AddClass(string) (gorex, error) produces a gorex object with a new class group of characters in the expression sequence. the classes consist of one or more of:
```
	NoClass string = ""
	Ascii string = "\x00-\x7F"
	Blank string = "\t "
	Control string = "\x00-\x1F\x7F"
	Digits string = "0-9"
	Graphical string = "!-~"
	Lowers string = "a-z"
	Printable string = " -~"
	Punctuation string = "!-/:-@[-`{-~"
	Whitespace string = "\t\n\v\f\r "
	Uppers string = "A-Z"
	Words string = "0-9A-Za-z_"
	HexDigits string = "0-9A-Fa-f"
	AlphaNumerics string = "0-9A-Za-z"
	Alphabetics string = "A-Za-z"
```

This produces a group like: `([A-Z])`

gorex.AddClassToLast(string) (gorex, error) produces a gorex object with a class group added to the previously created class sequence. Use this to add additional character options to a single character field (EG supporting both upper-case and lower-case normally requires calls to AddClass(Uppers) and AddClassToLast(Lowers) to produce an "([A-Za-z])" filter.

gorex.AddFixed(string) (gorex, error) produces a gorex object with a new fixed group of one or more strings. Note, this only permits Ascii characters (0x00~0x7F). This expression only accepts one string.

This produces a group like: `(com)`

gorex.AddFixedToLast(string) (gorex, error) produces a gorex object with a new fixed string applied to the prior group using an OR operator. Note, this only permits Ascii characters (0x00~0x7F).

This produces a group like: `(com|net)`

gorex.ApplyQuantifier(Quantifier, ...int) (gorex, error) produces a gorex object with a quantifier applied to the last class or fixed token generated. Quantifiers must be any one of:
```
	Single Quantifier = ""
	ZeroOrMore Quantifier = "*"
	OneOrMore Quantifier = "+"
	ZeroOrOne Quantifier = "?"
	MinToMax Quantifier = "{%d,%d}"
	MinOrMore Quantifier = "{%d,}"
	Exactly Quantifier = "{%d}"
	ZeroOrMorePrefFewer Quantifier = "*?"
	OneOrMorePrefFewer Quantifier = "+?"
	ZeroOrOnePrefFewer Quantifier = "??"
	MinToMaxPrefFewer Quantifier = "{%d,%d}?"
	MinOrMorePrefFewer Quantifier = "{%d,}?"
	ExactlyPrefFewer Quantifier = "{%d}?"
```

So, if AddClass(Uppers) is used, only a single character from A through Z matches the expression, but if ApplyQuantifier(OneOrMore) is used, any number of any characters that all fall within A through Z match as a group.

This produces a group like: `([A-Z]+)`

Hopefuly you'll find that these function names are reasonably straight-forware, if they are, to some extent, verbose.

## example
The ex_main.go application provides a simple e-mail verification regular expression generation. Note--the verbose errors are not necessary; they are in the example go code, but not shown here:
```
package main

import(
  "fmt"
  // gorex is added for ease of referencing. '.' causes access to gorex.go exports to be immediately accessible (otherwise, must use 'gorex.' in front of everything from that package)
  . "github.com/dev-west/gorex"
  "regexp"
)

func main() {
    var g *Gorex

    validEmails := [...]string{ "joe@mail.org", "john_doe@co.net", "perry.@place.com" }
    invalidEmails := [...]string{ "_tobby@message.org", "goat@mail", "finn@.net" }

    // create expression object
    g, _ = GolangExpression()

    // add any combination or number of 'A-Za-z0-9+' for the user identifier of the e-mail to match any alphanumerics
    g.AddClass(Uppers)               // adds A-Z; group is then ([A-Z])
    g.AddClassToLast(Lowers)         // adds a-z; group is then ([A-Za-z])
    g.AddClassToLast(Digits)         // adds 0-9; group is then ([A-Za-z0-9])
    g.ApplyQuantifier(OneOrMore) // necessary to have at least one alphanumberic; adds OneOrMore '+' flag; final group: ([A-Za-z0-9]+)

    // add optional single character '.' or '_' character in an e-mail
    g.AddFixed(".")                  // adds '.'; group is then (.)
    g.AddFixedToLast("_")            // adds '_'; group is then (.|_)
    g.ApplyQuantifier(ZeroOrOne) // it's optional, OK if it's not there; adds ZeroOrOne '?' flag; final group: (.|_?)

    // add optional second any combination or number of 'A-Za-z0-9+' for the user identifier of the e-mail 
    g.AddClass(AlphaNumerics)        // adds A-Za-z0-9; group is then ([A-Za-z0-9])
    g.ApplyQuantifier(ZeroOrMore) // not necessary to have a second group of alphanumerics; adds ZeroOrMore '*' flag; final group: ([A-Za-z0-9]*)

    // add the '@' in the e-mail
    g.AddFixed("@")                  // adds a necessary singular '@'; final group: (@)

    // add the institution identifier of any number of alphanumerics
    g.AddClass(AlphaNumerics)        // adds A-Za-z0-9; group is then ([A-Za-z0-9])
    g.ApplyQuantifier(OneOrMore) // necessary to have at least one alphanumeric; adds OneOrMore '+' flag; final group: ([A-Za-z0-9]+)

    // adds the '.' of the predecessor top-level domain in the e-mail
    g.AddFixed(".")                  // adds a necessary singular '.'; final group: (.)

    // adds the top-level domain, supporting specific fixed options
    g.AddFixed("com")                // adds 'com' as an option; group is then (com)
    g.AddFixedToLast("net")          // adds 'net' as an option; group is then (com|net)
    g.AddFixedToLast("org")          // adds 'org' as an option; final group: (com|net|org)

    // create an expression string
    exp, _ := g.Output()                    // Expected output: ([A-Za-z0-9]+)(.|_?)([A-Za-z0-9]*)(@)([A-Za-z0-9]+)(.)(com|net|org)

    var rex = regexp.MustCompile(exp)       // create the regular expression state machine

    fmt.Printf("Expression: %s\n", exp)
    // Output:
    // Expression: ([A-Za-z0-9]+)(.|_?)([A-Za-z0-9]*)(@)([A-Za-z0-9]+)(.)(com|net|org)

    var r string
    for _, r = range(validEmails) { // checks valid emails via the regexp state machine
        fmt.Printf("Attempt: %s, value: %#v\n", r, rex.MatchString(r))
    }
    // Output:
    // Attempt: joe@mail.org, value: true
    // Attempt: john_doe@co.net, value: true
    // Attempt: perry.@place.com, value: true
    // Attempt: _tobby@message.org, value: true

    for _, r = range(invalidEmails) { // checks invalid emails via the regexp state machine
        fmt.Printf("Attempt: %s, value: %#v\n", r, rex.MatchString(r))
    }
    // Output:
    // Attempt: goat@mail, value: false
    // Attempt: finn@.net, value: false
}
```
